# 数据结构

## 数组

### 优点

- 空间效率高：数组为数据分配了连续的内存块，无需额外的结构开销
- 支持随机访问：数组允许在O(1)时间内访问任何元素
- 缓存局部性：当访问数组数组数据时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升操作的执行速度

### 缺点

- 插入与删除效率低：复杂度O(n)
- 长度不可变
- 空间浪费

## 数组与链表对比

|      | 查找 | 更新 | 插入 | 删除 |
| ---- | ---- | ---- | ---- | ---- |
| 数组 | O(1) | O(1) | O(n) | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(1) |

## 栈

数组和链表实现对比

时间效率

- 基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高
- 基于链表实现的栈可以提供更加稳定的效率表现

空间效率

基于数组实现的栈可能造成一定的空间浪费
链表节点需要额外存储指针

## 队列

当使用单向列表当作队列时有两种表现形式：

1. 队头在链表头部，队尾在链表尾部

优点：

- 出队操作 时间复杂度O(1)
- 入队操作 时间复杂度O(1)

缺点：

- 在队尾删除元素，需要遍历整个链表时间复杂度为O(n)

2. 队头在链表尾部，队尾在链表头部

优点：

- 入队操作 时间复杂度O(1)

缺点：

- 出队操作 需要遍历到倒数第二个节点 时间复杂度O(n)

## 栈

当使用单向列表当作栈时有两种表现形式：

1. 栈顶在链表头部，栈底在链表尾部

优点：

- 压栈直接在头部添加节点 时间复杂度O(1)
- 出栈直接在移除头部节点 时间复杂度O(1)

2. 栈顶在链表尾部，栈底在链表头部

缺点：

出栈和入栈都是O(n)

## 二叉树

完美二叉树：
所有层的节点被完全填满，若树的高度为h，则节点总数为2ʰ⁺¹ - 1

完全二叉树：
只有最底层的节点未被填满，且最底层节点尽量靠左填充

完满二叉树：
除了叶节点之外，其余所有节点都有两个子节点

平衡二叉树：
任意节点的左子树和右子树的高度之差的绝对值不超过1

二叉搜索树：

1. 对于根节点，左子树中所有节点的值< 根节点的值 < 右子树中所有节点的值
2. 任意节点的左、右子树也是二叉搜索树，即同样满足条件1

二叉搜索树的中序遍历是升序的

|          | 无序数组 | 二叉搜索树 |
| -------- | -------- | ---------- |
| 查找元素 | O(n)     | O(log(n))  |
| 插入元素 | O(1)     | O(log(n))  |
| 删除元素 | O(n)     | O(log(n))  |

AVL树：
既是二叉搜索树也是平衡二叉树

四种旋转情况选择条件

| 失衡节点的平衡因子 | 子节点的平衡因子 | 应采用的旋转方法 |
| ------------------ | ---------------- | ---------------- |
| > 1 (左偏树)       | >= 0             | 右旋             |
| > 1 (左偏树)       | < 0              | 先左旋后右旋     |
| < -1 (右偏树)      | <= 0             | 左旋             |
| < -1 (右偏树)      | > 0              | 先右旋后左旋     |

## 堆

堆是一种满足特定条件的完全二叉树

## 图

图是一种非线性数据结构，由顶点和边组成。
